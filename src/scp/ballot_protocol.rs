use std::{
    collections::BTreeMap,
    sync::{Arc, Mutex},
};

use super::{
    nomination_protocol::{HNominationValue, NominationValue},
    scp::{NodeID, SCP},
    scp_driver::SlotDriver,
    slot::HSCPEnvelope,
};

pub struct SCPStatement {}

#[derive(Eq, PartialEq, PartialOrd, Ord)]
pub struct SCPBallot {
    counter: u32,
    value: NominationValue,
}

impl SCPBallot {
    pub fn compatible(&self, other: &SCPBallot) -> bool {
        self.value == other.value
    }

    pub fn less_and_incompatible(&self, other: &SCPBallot) -> bool {
        self <= other && !self.compatible(other)
    }

    pub fn less_and_compatible(&self, other: &SCPBallot) -> bool {
        self <= other && self.compatible(other)
    }
}

impl Default for SCPBallot {
    fn default() -> Self {
        Self {
            counter: Default::default(),
            value: Default::default(),
        }
    }
}

#[derive(PartialEq, Eq)]
pub enum SCPPhase {
    PhasePrepare,
    PhaseConfirm,
    PhaseExternalize,
    PhaseNum,
}

pub trait BallotProtocol {
    fn externalize(&mut self);
    fn recv_ballot_envelope(&mut self);

    // `attempt*` methods are called by `advanceSlot` internally call the
    //  the `set*` methods.
    //   * check if the specified state for the current slot has been
    //     reached or not.
    //   * idempotent
    //  input: latest statement received (used as a hint to reduce the
    //  space to explore)
    //  output: returns true if the state was updated

    // `set*` methods progress the slot to the specified state
    //  input: state specific
    //  output: returns true if the state was updated.

    // step 1 and 5 from the SCP paper
    fn attempt_accept_prepared(
        self: &Arc<Self>,
        state: HBallotProtocolState,
        hint: &SCPStatement,
    ) -> bool;
    // prepared: ballot that should be prepared
    fn set_accept_prepared(state: &mut BallotProtocolState, prepared: &SCPBallot) -> bool;

    // step 2+3+8 from the SCP paper
    // ballot is the candidate to record as 'confirmed prepared'
    fn attempt_confirm_prepared(state: &mut BallotProtocolState, hint: &SCPStatement);
    // newC, newH : low/high bounds prepared confirmed
    fn set_confirm_prepared(
        state: &mut BallotProtocolState,
        newC: &SCPBallot,
        newH: &SCPBallot,
    ) -> bool;

    // step (4 and 6)+8 from the SCP paper
    fn attempt_accept_commit(state: &mut BallotProtocolState, hint: &SCPStatement) -> bool;
    // new values for c and h
    fn set_accept_commit(state: &mut BallotProtocolState, c: &SCPBallot, h: &SCPBallot) -> bool;

    // step 7+8 from the SCP paper
    fn attempt_confirm_commit(state: &mut BallotProtocolState, hint: &SCPStatement) -> bool;
    fn set_confirm_commit(
        state: &mut BallotProtocolState,
        acceptCommitLow: &SCPBallot,
        acceptCommitHigh: &SCPBallot,
    ) -> bool;

    // step 9 from the SCP paper
    fn attemptBump() -> bool;
}

pub type HBallot = Arc<Mutex<Option<SCPBallot>>>;

pub type HBallotProtocolState = Arc<Mutex<BallotProtocolState>>;
pub struct BallotProtocolState {
    pub heard_from_quorum: bool,

    pub current_ballot: HBallot,
    pub prepared: HBallot,
    pub prepared_prime: HBallot,
    pub high_ballot: HBallot,
    pub commit: HBallot,

    pub latest_envelopes: BTreeMap<NodeID, HSCPEnvelope>,
    pub phase: SCPPhase,
    pub value_override: HNominationValue,

    pub current_message_level: usize,

    // last envelope generated by this node
    pub last_envelope: HSCPEnvelope,

    // last envelope emitted by this node
    pub last_envelope_emitted: HSCPEnvelope,
}

impl Default for BallotProtocolState {
    fn default() -> Self {
        Self {
            heard_from_quorum: Default::default(),
            current_ballot: Default::default(),
            prepared: Default::default(),
            prepared_prime: Default::default(),
            high_ballot: Default::default(),
            commit: Default::default(),
            latest_envelopes: Default::default(),
            phase: SCPPhase::PhasePrepare,
            value_override: Default::default(),
            current_message_level: Default::default(),
            last_envelope: Default::default(),
            last_envelope_emitted: Default::default(),
        }
    }
}
